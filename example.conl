# CONL is a post-minimalist, human-centric configuration language.

# There are four ways to define a value:
scalar = value

list
  = value1
  = value2

map
  key1 = value1
  key2 = value2

multiline_scalar = """
  value

# For multiline scalars, you can specify a tag for syntax highlighting.
init_script = """bash
  #!/bin/bash

  echo "hello world"

# Quoting is not required. Leading and trailing whitespace is ignored.
# but keys and values can contain any characters (*conditions apply)
spaced out key = value with = signs and "quotes"!

# To make it safe to include URLs as values, # is only a comment
# after whitespace.
a = https://example.com#a # jump to section a

# But the space around the = sign is purely for readability
short=16 bits

# It is possible to nest lists and maps as needed.
# (and as in JSON, types can be mixed however you want)
json_like
  sub_map
    key = value
  sub_list
    = value
    =
      map = no problem
    =
      = a list in a list # in a map in a map
  sub_value = 5

# For more esoteric uses, you can use a quoted literal.
# A quoted literal can represent any string of unicode characters.
# They are for situations like keys with = signs, or values
# with leading whitespace that CONL cannot otherwise represent.
quoted_literal = "\twow\ttabs!\t"
# Quoted literals support the following escape sequencess:
escape_sequences
  = "\\" # '\'
  = "\"" # '"'
  = "\t" # tab
  = "\n" # newline
  = "\r" # carriage return
  = "\{0}" # U+0000
  = "\{1F321}" # üê± (or any Unicode codepoint valid in UTF-8)

# Variable types are not syntactically distinct.
# The app you are configuring already knows what to expect.
enabled = yes
country_code = no

# CONL has no null, so you should comment out values you don't wish to set.
overrides
  # bits_per_byte = 8
  int_size = 32

# Missing values are interpreted as appropriate for the type.
# ["ribbon", "", "kittens"] if you were expecting strings.
my favoite things
  = ribbon
  = # empty
  = kittens
